---
title: How I boosted my Vim
author: Vincent Driessen
created_at: 2010-08-15
modified_at: 2010-08-24
kind: article
status: draft
---
A few weeks ago, I took some time to configure and fine-tune my Vim
environment.  A lot of new stuff made it into my @.vimrc@ file and my @.vim@
directory.  This blog post is a summary describing what I've added and how I
use it in my daily work.

Before doing anything else, make sure you have the following line in your
@.vimrc@ file:

<pre><code class="language-vim">
" This must be first, because it changes other options as side effect
set nocompatible
</code></pre>


h2(#pathogen). Step 0: make the customization process easier

Before starting configuring, it's useful to install
"pathogen":http://www.vim.org/scripts/script.php?script_id=2332.  Plugins in
Vim are files that you drop in subdirectories of your @.vim/@ directory.  Many
plugins exist of only a single file that should be dropped in @.vim/plugin@,
but some exist of multiple files.  For example, they come with documentation,
or ship syntax files.  In those cases, files need to be dropped into
@.vim/doc@ and @.vim/syntax@.  This makes it difficult to remove the plugin
afterwards.  After installing pathogen, you can simply unzip a plugin
distribution into @.vim/bundle/myplugin@, under which the required
subdirectories are created.  Removing the plugin, then, is as simple as
removing the @myplugin@ directory.

So, download @pathogen.vim@, move it into the @.vim/autoload@ directory (create
it if necessary) and add the following lines to your @.vimrc@, to activate it:

<pre><code class="language-vim">
" Use pathogen to easily modify the runtime path to include all
" plugins under the ~/.vim/bundle directory
call pathogen#helptags()
call pathogen#runtime_append_all_bundles()
</code></pre>

Besides that, this is a little tweak that is a time-saver while you're building
up your @.vimrc@:

<pre><code class="language-vim">
" Quickly edit/reload the vimrc file
nmap <silent> <leader>ev :e $MYVIMRC<CR>
nmap <silent> <leader>sv :so $MYVIMRC<CR>
</code></pre>

This maps the @,ev@ and @,sv@ keys to edit/reload @.vimrc@.  (I got this from
Derek Wyatt's @.vimrc@ file.)

Notice that I've remapped the leader key to @,@ (comma) instead of the default
@\@ (backslash), just because I like it better.  Since in Vim's default
configuration, almost every key is already mapped to a command, there needs to
be some sort of standard "free" key where you can place custom mappings under.
This is called the "mapleader", and can be defined like this:

<pre><code class="language-vim">
" change the mapleader from \ to ,
let mapleader=","
</code></pre>


h2. Change Vim behaviour

One particularly useful setting is @hidden@.  Its name isn't too descriptive,
though.  It _hides_ buffers instead of _closing_ them.  This means that you can
have unwritten changes to a file and open a new file using @:e@, without being
forced to write or undo your changes first.  Also, undo buffers and marks are
preserved while the buffer is open.  This is an absolute must-have.

<pre><code class="language-vim">
set hidden
</code></pre>

These are some of the most basic settings that you probably want to enable,
too:

<pre class="big-box"><code class="language-vim">
set nowrap        " don't wrap lines
set tabstop=4     " a tab is four spaces
set backspace=indent,eol,start
                  " allow backspacing over everything in insert mode
set autoindent    " always set autoindenting on
set copyindent    " copy the previous indentation on autoindenting
set number        " always show line numbers
set shiftwidth=4  " number of spaces to use for autoindenting
set shiftround    " use multiple of shiftwidth when indenting with '<' and '>'
set showmatch     " set show matching parenthesis
set ignorecase    " ignore case when searching
set smartcase     " ignore case if search pattern is all lowercase,
                  "    case-sensitive otherwise
set smarttab      " insert tabs on the start of a line according to
                  "    shiftwidth, not tabstop
set hlsearch      " highlight search terms
set incsearch     " show search matches as you type
</code></pre>

There is a lot more goodness in my
"@.vimrc@":http://github.com/nvie/vimrc/raw/master/vimrc file, which is put in
there with a lot of love.  I've commented most of it, too.  Feel free to poke
around in it.

Also, I like Vim to have a large undo buffer, a large history of commands,
ignore some file extensions when completing names by pressing Tab, and be
silent about invalid cursor moves and other errors.

<pre><code class="language-vim">
set history=1000         " remember more commands and search history
set undolevels=1000      " use many muchos levels of undo
set wildignore=*.swp,*.bak,*.pyc,*.class
set title                " change the terminal's title
set visualbell           " don't beep
set noerrorbells         " don't beep
</code></pre>

Oh, and man... never ever let Vim write a backup file!  They did that in the
70's.  Use "modern":http://git-scm.com/ ways for tracking your changes, for
God's sake.

<pre><code class="language-vim">
set nobackup
set noswapfile
</code></pre>


h2. Use file type plugins

Vim can detect file types (by their extension, or by peeking inside the file).
This enabled Vim to load plugins, settings or key mappings that are only useful
in the context of specific file types.  For example, a Python syntax checker
plugin only makes sense in a Python file.  Finally, indenting intelligence is
enabled based on the syntax rules for the file type.

<pre><code class="language-vim">
" set filetype stuff to on
filetype on
filetype plugin on
filetype indent on
</code></pre>

To set some file type specific settings, you can now use the following:

<pre><code class="language-vim">
autocmd filetype python set expandtab
</code></pre>

To remain compatible with older versions of Vim that do not have the @autocmd@
functions, always wrap those functions inside a block like this:

<pre><code class="language-vim">
if has('autocmd')
    ...
endif
</code></pre>


h2. Enable syntax highlighting

Somewhat related to the file type plugins is the syntax highlighting of
different types of source files.  Vim uses syntax definitions to highlight
source code.  Syntax definitions simply declare where a function name starts,
which pieces are commented out and what are keywords.  To color them, Vim uses
colorschemes.  You can load custom color schemes by placing them in
@.vim/colors@, then load them using the @colorscheme@ command.  You have to try
what you like most.  I like
"mustang":http://hcalves.deviantart.com/art/Mustang-Vim-Colorscheme-98974484 a
lot.

<pre><code class="language-vim">
if &t_Co >= 256 || has("gui_running")
   colorscheme mustang
endif

if &t_Co > 2 || has("gui_running")
   " switch syntax highlighting on, when the terminal has colors
   syntax on
endif
</code></pre>

In this case, mustang is only loaded if the terminal emulator Vim runs in
supports at least 256 colors (or if you use the GUI version of Vim).

*Hint*: if you're using a terminal emulator that can show 256 colors, try
setting @TERM=xterm-256color@ in your terminal configuration or in your shell's
.rc file.


h2. Change editing behaviour

When you write a lot of code, you probably want to obey certain style rules.
In some programming languages (like Python), whitespace is important, so you
may not just swap tabs for spaces and even the number of spaces is important.

Vim can highlight whitespaces for you in a convenient way:

<pre><code class="language-vim">
set list
set listchars=tab:>.,trail:.,extends:#,nbsp:.
</code></pre>

This line will make Vim set out tab characters, trailing whitespace and
invisible spaces visually, and additionally use the @#@ sign at the end of
lines to mark lines that extend off-screen.  For more info, see @:h listchars@.

In some files, like HTML and XML files, tabs are fine and showing them is
really annoying, you can disable them easily using an @autocmd@ declaration:

<pre><code class="language-vim">
autocmd filetype html,xml set listchars-=tab:>.
</code></pre>

One caveat when setting @listchars@: if nothing happens, you have probably not
enabled @list@, so try @:set list@, too.


h3. Pasting large amounts of text into Vim

Every Vim user likes to enable auto-indenting of source code, so Vim can
intelligently position you cursor on the next line as you type.  This has one
big ugly consequence however: when you paste text into your terminal-based Vim,
Vim cannot know it is coming from a paste.  To Vim, it looks like text entered
by someone who can type incredibly fast :)  You often find something similar to
this as a result:

p=. !/img/2010/08/ugly-paste2.png!

There is an easy option to prevent this, however.  You can temporarily switch
to "paste mode", simply by setting the following option:

<pre><code class="language-vim">
set pastetoggle=<F2>
</code></pre>

Then, when in insert mode, ready to paste, if you press @<F2>@, Vim will switch
to paste mode, disabling all kinds of smartness and just pasting a whole buffer
of text.  Then, you can disable paste mode again with another press of @<F2>@.
Nice and simple.  Compare:

p=. !/img/2010/08/better-paste2.png!


h2. Enable the mouse

While using the mouse is considered a deadly sin among Vim users, there _are_ a
few features about the mouse that can really come to your advantage.  Most
notably--scrolling.  In fact, it's the only thing I use it for.

Also, if you are a rookie Vim user, setting this value will make your Vim
experience definitively feel more natural.

To enable the mouse, use:

<pre><code class="language-vim">
set mouse=a
</code></pre>

However, this comes at one big disadvantage: when you run Vim inside a
terminal, the terminal itself cannot control your mouse anymore.  Therefore,
you cannot select text anymore with the terminal (to copy it to the system
clipboard, for example).

To be able to have the best of both worlds, I wrote this simple Vim plugin:
"vim-togglemouse":http://github.com/nvie/vim-togglemouse.  It maps @<F12>@ to
toggle your mouse "focus" between Vim and the terminal.

Small plugins like these are really useful, yet have the additional benefit of
lowering the barrier of learning the Vim scripting language.  At the core, this
plugin exists of only one simple function:

<pre><code class="language-vim">
fun! s:ToggleMouse()
    if !exists("s:old_mouse")
        let s:old_mouse = "a"
    endif

    if &mouse == ""
        let &mouse = s:old_mouse
        echo "Mouse is for Vim (" . &mouse . ")"
    else
        let s:old_mouse = &mouse
        let &mouse=""
        echo "Mouse is for terminal"
    endif
endfunction
</code></pre>


h2. Get efficient: shortcut mappings

The following trick is a really small one, but a super-efficient one, since it
strips off two full keystrokes from almost every Vim command:

<pre><code class="language-vim">
nnoremap ; :
</code></pre>

For example, to save a file, you type @:w@ normally, which means:

# Press and hold Shift
# Press @;@
# Release the Shift key
# Press @w@
# Press Return

This trick strips off steps 1 and 3 for *each* Vim command.  It takes some
times for your muscle memory to get used to this new @;w@ command, but once you
use it, you don't want to go back!

I also find this key binding very useful, since I like to reformat paragraph
text often.  Just set your cursor inside a paragraph and press @Q@ (or select a
visual block and press @Q@).

<pre><code class="language-vim">
" Use Q for formatting the current paragraph (or selection)
vmap Q gq
nmap Q gqap
</code></pre>

If you are still getting used to Vim and want to force yourself to stop using
the arrow keys, add this:

<pre><code class="language-vim">
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>
</code></pre>

If you like long lines with line wrapping enabled, this solves the problem that
pressing down jumpes your cursor "over" the current line to the next line.  It
changes behaviour so that it jumps to the next row in the editor (much more
natural):

<pre><code class="language-vim">
nnoremap j gj
nnoremap k gk
</code></pre>

When you start to use Vim more professionally, you want to work with multiple
windows open.  Navigating requires you to press @C-w@ first, then a navigation
command (h, j, k, l).  This makes it easier to navigate focus through windows:

<pre><code class="language-vim">
" Easy window navigation
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
</code></pre>

Tired of clearing searches by searching for @ldsfhj khgakjksgdhgksjd@ (or
similar)?  Use this:

<pre><code class="language-vim">
nmap <silent> ,/ :let @/=""<CR>
</code></pre>

It clears the search buffer when you press @,/@

Finally, a trick by "Steve
Losh":http://forrst.com/posts/Use_w_to_sudo_write_a_file_with_Vim-uAN for when
you forgot to @sudo@ before editing a file that requires root privileges
(typically @/etc/hosts@).  This lets you use @w!!@ to do that *after* you
opened the file already:

<pre><code class="language-vim">
cmap w!! w !sudo tee % >/dev/null
</code></pre>


h2. NERDTree explorer

Vim's NERDTree plugin is an absolute must for almost any Vim user.  For those
who don't know it yet, NERDTree is a file browser that allows you to quickly
open files by navigating onto it and pressing Return.


h2. Fugitive (fuGITive?)
by Tim Pope

Plugin for Git integration.  I *love* the :Gedit command, for quickly editing a
file in the index.


h2. Python: PEP8, pyflakes and unit test integration

In essence, Vim is a text editor.  It is not an integrated development
environment.  However, since it is so extendible, you can come a long way to
such a situation nevertheless.

Many plugins are available that cover a lot of "IDE functionality" already.
Sometimes however, you need functionality that you cannot find in an already
available plugin (or in a way that doesn't fit your need).  In those cases, you
can extend Vim yourself.

This happened to me when I started doing a lot of Python development.  I often
want to run QA tools (like @pep8@ or @pyflakes@) on my Python source code.
There are plugins for those tools available, but

* they don't allow me to customize any key mappings
* they don't look/act/behave the same, although they may be considered the same
  type of tools (i.e. they tell me on what lines there's something wrong with
  my Python source)
* in the best case, they are merely a simple wrapper around a shell invocation

Before I've tried these plugins, I had an ad hoc key mapping defined to call
@pep8 -r@ on the current file.  Vim would show me the shell output, I'd
remember a line number, press Return, type [@:n@] (where @n@ is the line
number) and start fixing it.

However, you can get it a lot better than that.  I dove into the details of
@makeprg@, @makeformat@ and the quickfix window, and came up with the following
coherent set of plugins:

* "vim-pep8":http://github.com/nvie/vim-pep8
* vim-pyflakes
* vim-pyunit

Each of them is usable on its own, but they complete each other beautifully.

I started creating the first two, since those where the simplest.  The base
where I started off from was a list of functions I found in Gary Bernhardt's
"@.vimrc@":http://bitbucket.org/garybernhardt/dotfiles/src/tip/.vimrc file.  I
liked the idea of his unit testing functions showing a red or a green bar,
since it somehow is a visually pleasing result.  Gary did a splendid job
already in setting up the basic logic for this, but his code was rather
intertwined within his @.vimrc@ file and not easily reusable.

Going from there, I decided to learn a bit of the Vim script language and come
up with my own.

h3. PEP8

The PEP8-plugin checks whether your Python file comforms to the "PEP8 style
guide":http://www.python.org/dev/peps/pep-0008/. There is a simple tool called
"@pep8@":http://pypi.python.org/pypi/pep8 that can do that check automatically
for you.  It simply returns output that looks like this:

bc. $ pep8 urls.py
urls.py:10:1: E302 expected 2 blank lines, found 1
urls.py:12:3: E111 indentation is not a multiple of four
urls.py:16:80: E501 line too long (99 characters)

The "@vim-pep8@":http://github.com/nvie/vim-pep8 plugin uses Vim's @grepprg@
functionality to turn that output into a quickfix list (see @:h quickfix@) that
looks something like this:

!/img/2010/08/quickfix-window.png!

Or something like this when the file is clean:

!/img/2010/08/pep8-safe.png!

When you install the plugin into your @.vim/bundle/pep8@ directory (you use
"pathogen":#pathogen, right?), you get this functionality mapped by default
under the @<F6>@ key.  If you wish to remap this, you can easily do so with the
following command (which puts it under @,p@ for example):

<pre><code class="language-vim">
autocmd filetype python map <buffer> ,p :call Pep8()<CR>
</code></pre>


h3. pyflakes

The static compile-time syntax checker
"pyflakes":http://divmod.org/trac/wiki/DivmodPyflakes is a tool for quickly
checking whether there are typo's or bugs in your code that could lead to
untime issues.


h3. PyUnit

...




fn1. Of course, "inefficient" is a relative term when using Vim already.

fn2. Or she. But probably he.

fn3. Which made it hard to notice, even!
