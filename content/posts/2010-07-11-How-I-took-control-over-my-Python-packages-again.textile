---
status: draft
kind: article
author: Vincent Driessen
created_at: 2010-07-11
modified_at: 2010-07-11
title: How I took control over my Python packages again
alt_url: /archives/515
---
Starting development with Python is really easy. It has one of the easiest package management systems out there and with an internet connection, you are up and running with about any Python package in under a minute.

Especially when you have installed @easy_install@, it's extremely easy:

<pre><code>$ easy_install mypackage</code></pre>

In fact, it's so easy that at a certain moment, you find yourself having installed a "scary amount of packages":http://pastie.org/990457. The problem with this is that it's one big pile of packages.
# * All of the package paths are scanned when Python imports modules. Although the performance of Python is really good, you may start to feel an impact in the long term.
* Packages are versioned, but at most one version of a package can be used at a time. Mostly, this is no problem. But what if two different Python projects have different version requirements?
* There is no uninstaller. No really. You cannot uninstall packages.
* There is no way of telling which package belongs to which project.
* Since the packages are all put in the global Python's directory by default, you must be root to use new packages.

h2. Using virtual environments

Advanced Python developers know of "virtualenv":http://pypi.python.org/pypi/virtualenv, a great tool by "@ianbicking":http://twitter.com/ianbicking. For those who don't: @virtualenv@ lets you create a new, isolated virtual environment, an isolated installation of Python. With that comes an isolated copy of your packages (the so called @site-packages@ directory).

Creating one is really easy:

<pre><code>$ which python
/usr/bin/python
$ mkdir virtualenvs
$ cd virtualenvs
$ virtualenv --no-site-packages main
New python executable in main/bin/python
Installing setuptools............done.
$ source main/bin/activate
(main)$ which python
/home/nvie/virtualenvs/main/bin/python</code></pre>

As you can see, the @activate@ script puts you "into" this virtual environment. Actually, all that it does is modify your environment variable @$PATH@ to put the virtual env's @python@ (and @easy_install@, and @pip@) binaries before the system-wide ones. You can always "quit" a virtual env by typing @deactivate@.

h2. Never ever run @/usr/bin/python@ again

I recommend setting up a "main" Python virtual env in your home dir, and always use that one, instead of the system-wide one. This would already be useful if it merely relieved you of becoming root every time you want to install a package. But there's more. You _own_ the packages now.

Use that virtual env while you're developing your common Python code, but for larger projects you can consider creating a dedicated virtual env. That way, you are completely in control.

h2. Building requirement lists

Another chief advantage of using virtual env
